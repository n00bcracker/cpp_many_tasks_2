# Matrix-3.0

Теперь, когда вы стали специалистом по написанию интерпретаторов, вам не составит
труда написать еще один. Наш интерпретатор будет вычислять бесконечно полезные программы такого типа (все операции выполняются по некоторому модулю)

```
A = 1
B = 1
for 1000000000000000000
    C = A
    C += B
    A = B
    B = C
```

или

```
mul = 1
for 1000000000
    mul *= 2
    for 1000000
        s += mul
```

Для решения этой задачи полезно вспомнить идеи решений прошлых задач

* [Бинарное возведение в степень](https://gitlab.manytask.org/cpp0/public-2022-fall/tree/master/bin-pow)
* [Matrix](https://gitlab.manytask.org/cpp0/public-2022-fall/tree/master/matrix)
* [Калькулятор](https://gitlab.manytask.org/cpp0/public-2022-fall/tree/master/calculator)

### Язык

Наш язык поддерживает присваивающие операции, а также простые циклы. Цикл задается командой

```
for ITER
    body
```

ITER при этом обязан быть константой, body --- тело цикла, которое определяется величиной отступа. Все команды с одной величиной отступа лежат в одном цикле, размер
отступа кратен 4, отступ задается пробелами.

Циклы не влияют на видимость переменных (т.е. все переменные глобальные), и все переменные изначально равны 0. Имя переменной (обозначается далее как VAR) состоит из маленьких и больших латинских букв, цифр и символа `_`. Имя обязано начинаться с буквы и не может быть равно `for`.

Присваивающие операции имеют вид

```
VAR = EXPR
VAR += EXPR
VAR -= EXPR
VAR *= CONST
```

Под CONST понимается какая-то константа (число). EXPR --- арифметическое выражение,
состоящее из чисел, переменных, скобок, а также операций +, - (в том числе унарного), *.

Стоит отметить однако, что на EXPR наложено важное ограничение. После раскрытия всех скобок EXPR должно образовывать линейную комбинацию переменных, т.е. следующее присваивание невалидно:

```
A = B * C
```

Далее будет понятно, зачем оно введено. Больше примеров программ можно посмотреть в тестах.

### Алгоритм

Пусть во введенной программе используются только переменные A, B и C. Тогда состояние
программы можно представить вектором из значений переменных. Добавим также фиктивную
переменную со значением 1. Таким образом состоянием будет вектор `(A, B, C, 1)`.
Изначально это состояние равно `(0, 0, 0, 1)`. Рассмотрим операцию `A = 5`. После
ее выполнения состояние должно стать `(5, 0, 0, 1)`. Заметим, что это можно представить как матричное умножение

```math
(0, 0, 0, 1) \cdot \left(
\begin{matrix}
0 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
5 & 0 & 0 & 1
\end{matrix} \right)
```

Если текущее состояние `(A, B, C, 1)`, то операции `B += 2 * C` будет соответствовать умножение на матрицу

```math
(A, B, C, 1) \cdot \left(
\begin{matrix} 
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 2 & 1 & 0\\
0 & 0 & 0 & 1
\end{matrix} \right)
```

Эти матрицы составляются согласно правилам умножения. Каждой переменной соответствует
один столбец. Пусть мы меняем $`i`$-ую переменную. Тогда в $`j`$-ой строке $`i`$-ого столбца
должен быть записан коэффициент, с которым $`j`$-ая переменная входит в выражение, которое присваивается в $`i`$-ую переменную.

Таким образом любое присваивание в нашей программе выражается как умножение текущего
вектора состояния на некоторую матрицу. Тогда последовательность операций
$`O_1, \dots, O_k`$ можно представить как последовательность умножений
$`init \cdot M(O_1) \cdot \ldots M(O_k)`$, где init это начальное состояние, а
$`M(O_i)`$ --- матрица, соответствующая $`i`$-ой операции.

Это означает, что любую программу без циклов можно в сжатом виде представить в виде матрицы ---
нужно просто перемножить все $`k`$ матриц. Меняя начальное состояние, можно быстро перевыполнять программу для новых начальных значений переменных --- достаточно перемножить начальное состояние и матрицу, соответствующую программе.

Пусть теперь имеется цикл

```
for 100
    body
```

Это все равно, что записать body 100 раз подряд. Тогда чтобы получить матричное представление данной программы, нужно умножить M(body) саму на себя 100 раз
(здесь M(body) это матрица, соответствующая программе body), т.е.
вычислить $`(M(body))^{100}`$. А поскольку матричное умножение ассоциативно, это можно
быстро вычислить с помощью бинарного возведения в степень.

Теперь можно сделать интерпретатор. Его задачей будет построение матрицы, соответствующей программе. Чтобы получить итоговые значения переменных, нужно просто умножить начальное состояние `(0, 0, ..., 1)` на эту матрицу.

Будем поддерживать матрицу, соответствующую программе, изначально она единичная. Если задана присваивающая операция, то строим соответствующую данной операции матрицу, после чего текущую умножаем на нее
(умножение матриц не коммутативно и порядок умножения важен). Если же встретили цикл
`for C`, то рекурсивно построим матрицу $`Z`$ для тела цикла, после чего умножим текущую матрицу на $`Z^C`$.

### Задача

Реализуйте функцию `Run`, которая принимает программу и возвращает `map`, где для каждой
переменной записано ее итоговое значение. Все вычисления выполняйте в типе `uint64_t` (т.е. по модулю $`2^{64}`$).

Если программа некорректна, бросайте исключение, производное от `std::exception`.

Ваша функция должна быть в файле `interpreter.h`, но вы можете создавать произвольное число .h файлов для удобства.

Если вы писали калькулятор не абы как, то сейчас должны быть в состоянии полностью переиспользовать код оттуда.
