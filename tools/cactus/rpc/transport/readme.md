# transport

Реализуйте простой транспорт для RPC.

Реализация должна находиться в классах `SimpleRpcChannel` и `SimpleRpcServer`.

## Протокол

Клиент подключается к серверу по TCP и пишет запрос.

В начале запроса идёт фиксированный заголовок.

```c++
struct FixedHeader {
    uint32_t header_size;
    uint32_t body_size;
};
```

За заголовком следует proto сообщение типа RequestHeader и размера header_size.
Затем идёт proto сообщение запроса размера body_size.

Сервер отвечает фиксированным заголовком. За заголовком идёт proto сообщение
типа ResponseHeader размера header_size.
За ним идёт сообщение с ответом на запрос.

Тесты находятся в исполняемом файле `test_cactus_rpc_transport`.

## Замечания

- Классы RequestHeader и ResponseHeader определены в cactus/rpc/rpc.proto.
  * В классе RequestHeader пишутся полное имя сервиса и имя метода,
    к которому осуществляется запрос.
  * Класс ResponseHeader может содержать сообщение типа RpcError,
    в котором находится текст ошибки.
- Если вы правильно сделали задание gen-rpc, то файл `rpc.pb.h` у вас
  инклюдит файл `rpc.h`. Это значит, что `rpc.pb.h` нельзя инклюдить в `rpc.h`.
  Если вы нарушите это правило, то скорее всего компиляция будет падать
  с ошибкой `error: ‘RequestHeader’ was not declared in this scope`.
- При ошибке (обращение к незарегистрированному сервису, невалидный формат запроса,
  исключение при обработки запроса и т.д) сервер должен возвращать RpcError, а клиент
  должен кидать исключение типа cactus::RpcCallError.
