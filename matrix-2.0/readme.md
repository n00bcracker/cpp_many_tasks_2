# Matrix 2.0

В этой задаче мы посмотрим, ~~какой треш можно творить~~ какие широкие возможности открывают шаблоны в C++.
Мы хотим оптимизировать последовательность матричных умножений. Допустим есть следующий код:

```
Matrix D = A * B * C;
```

Допустим матрицы имеют размеры $`A_{50 \times 5}, B_{5 \times 100}, C_{100 \times 10}`$. Тогда в силу ассоциативности умножения
матриц, результат можно посчитать двумя способами:

```math
D = (AB)C
D = A(BC)
```

Причем в первом случае мы сделаем $`50 \cdot 5 \cdot 100 + 50 \cdot 100 \cdot 10 = 75000`$ скалярных умножений, а во втором
$`5 \cdot 100 \cdot 10 + 50 \cdot 5 \cdot 10 = 7500`$, т.е. в 10 раз меньше. Наша задача --- реализовать `*` для Matrix таким образом,
чтобы последовательность перемножений была оптимальной.

### Пролог

Для начала вам понадобится класс `Matrix`, подобный тому, который вы реализовали в задаче [matrix](https://gitlab.manytask.org/cpp0/public-2022-fall/tree/master/matrix). Параметризуйте его типом хранящихся элементов `T`. Реализуйте все те же методы, что и в прошлой задаче, за исключением
функций `Transpose`, `Identity`, а также присваивающих операторов `+=,-=,*=`, которые мы здесь не используем.

Не реализуйте пока оператор `*`.
Обратите внимание, что имеет смысл реализовать `+,-` как друзей класса,
причем определить их **внутри** класса.
Нам это понадобится в дальнейшем.

### Первый шаг

Проблема в том, что в языке жестко зафиксировано, что оператор `*` левоассоциативен, т.е. компилятор всегда будет раскрывать его как
`((A*B)*C)*D`, и с этим ничего нельзя сделать. Нам же нужно каким-то образом получить весь список операндов (A, B, C, D), который потом
вычислить в оптимальном порядке. Можно сделать такой оператор умножения, который сохраняет внутри себя информацию о двух операндах.
Определим структуру, которая содержит пару ссылок на левый и правый аргументы:

```c++
struct Glue {
    const Matrix& left;
    const Matrix& right;
};
```

Тогда можно определить оператор умножения следующим образом:

```c++
Glue operator*(const Matrix& left, const Matrix& right) {
    return Glue{left, right};
}
```

Проблема теперь в том, что такой `*` работает только для двух аргументов. Т.е. для цепочки (A * B) * C нам нужен еще такой `*`, который
принимает уже `Glue` и `Matrix`, причем в результирующем `Glue` левый операнд `left` должен уже иметь тип `Glue`, а не
`Matrix`. Как этого добиться? Давайте параметризуем `Glue` типом левого аргумента, т.е. `Glue<L>`. Аналогично поступим
с оператором `*`. Реализуйте шаблонную версию `Glue` и оператора `*`. В этом случае для `A * B * C * D` результат будет иметь тип

```
Glue<Glue<Glue<Matrix>>>
```

### Обход дерева

Таким образом все аргументы `*` у нас сейчас хранятся в подобном дереве:

```
    Glue
   /    \
  Glue   D
  /   \
 Glue  C
 /  \
A    B
```

Реальное вычисление произведения разумно делать в соответствующем конструкторе Matrix.
Например, пусть мы пишем

```c++
Matrix<int> e = a * b * c * d;
```

Тогда как мы уже видели, тип выражения справа от `=` это какой-то `Glue`, и мы зовем конструктор `Matrix` от `Glue`, т.е. нужно определить

```c++
template <class L>
Matrix(const Glue<L>& tree);
```

Внутри конструктора нужно обойти дерево,
получив список листьев `const Matrix* operands[count]`

### Оптимизация умножений

После того, как вы выписали все матрицы (а точнее указатели на них, чтобы не копировать лишнего) в массив, можно определить оптимальный
порядок вычислений. Для этого воспользуйтесь [динамическим программированием](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B5_%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F_%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86).

Перед тем, как начать это делать, стоит проверить, что все размеры матриц совместимы. Если это не так, нужно бросить исключение типа
`std::runtime_error`.

### Смешанные операции

Если вы все сделали правильно, то у вас будут работать и выражения вида
```c++
Matrix<int> a = b * c + d * e;
```

Даже несмотря на то, что оператор `+` не принимает `Glue`. Тут стоит вспомнить, что конструктор `Matrix(Glue)` не `explicit`, поэтому
компилятор выполняет неявное преобразование типа (причем вычисляя по ходу результат умножения). В контексте шаблонов такое неявное
преобразование будет происходить только в том случае, если оператор объявлен как внешняя функция, но внутри класса. Объявить функцию
как внешнюю, но внутри класса, можно только с помощью `friend` и только реализовав ее прямо в классе. Подробнее читайте у Майерса.

### Последний штрих

На самом деле с нашим оператором `*` есть небольшая проблема --- он принимает
аргумент произвольного типа `L`, после чего
склеивает его в `Glue<L>`. Проблема в том, что теперь такой оператор определен,
например, и для `std::string * Matrix<int>`, что неправильно.

Вам нужно как-то обозначить, что `L` это либо `Matrix`, либо произвольный `Glue`.
