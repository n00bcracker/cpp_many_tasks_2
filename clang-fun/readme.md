# Clang tooling

В этой задаче от вас требуется написать небольшую утилиту с использованием
[clang tooling](https://clang.llvm.org/docs/LibTooling.html).

Поставьте необходимые пакеты:
```bash
$ wget https://apt.llvm.org/llvm.sh
$ chmod +x llvm.sh
$ sudo ./llvm.sh 16 all
```

Утилита должна проверять имена, используемые в коде, на соответствие Google Styleguide,
а также искать потенциальные опечатки в этих именах.

Решение реализуйте в файле `checker/check_names.cpp`.
Вы можете создавать произвольные `.h` и `.cpp` файлы
в директории `checker`, они также будут
учитываться при проверке вашего решения.

## Styleguide

Имена сущностей в коде должны соответствовать описанным здесь правилам:
https://google.github.io/styleguide/cppguide.html#Naming.
Впрочем, есть некоторые отличия и исключения:

1. Нужно проверять только имена переменных, членов классов, типов, констант,
функций и перечислений.
2. Для констант и constexpr переменных всегда используется стиль kConstName,
даже если это член класса.
3. Есть отдельное правило для заглавных букв в тех именах, где они допустимы
(т.е. не в именах переменных, членах классов). В имени
могут встречаться последовательности из заглавных букв,
при этом их длина должна быть не меньше 3 без учёта начала следующего слова.
Например, `BuildDSUnion` невалидное имя, т.к. длина `DS` равна 2,
а `U` начинает следующее слово. `BuildDSU` или
`CreateASTMatcher` --- примеры валидных имен.
Имя не может целиком состоять из заглавных букв.
4. В именах всех сущностей запрещены цифры.

Разумеется, нужно реагировать только на объявления сущностей.

Это учебная задача --- в реальности `clang-tidy`
умеет проверять имена на соответствие стайлгайду.

## Требования к реализации
* Ваш собственный код должен проходить вашу же проверку --- это проверяется в тестах.
* Если невалидное имя возникло внутри макроса, то должно выводиться место его раскрытия,
а не место внутри макроса.
* Проверяемый файл может подключать другие файлы через `#include`.
Вам надо выводить ошибки только в несистемных подключаемых файлах.

## Поиск опечаток

Вашей программе может быть передана опция `-dict path_to_dict`, где `path_to_dict` ---
словарь, текстовый файл, в каждой строке которого
записано одно слово. В этом случае ваша утилита также должна производить поиск опечаток.
Если переменная удовлетворяет правилам выше,
то для каждого слова в её имени нужно поискать "ближайшее" к нему из словаря.
В качестве меры близости используется
[расстояние Левенштейна](https://en.wikipedia.org/wiki/Levenshtein_distance).
Пусть слово из имени `x`, ближайшее к нему `y`,
а `d(x, y)` --- расстояние между ними.
Тогда опечаткой считается случай `0 < d(x, y) < 4`.
В рамках данной задачи от вас не требуется реализовывать поиск ближайшего слова
эффективно, поэтому можете использовать простой линейный поиск по словарю.
Проверку нужно делать только для слов длины > 3.

## Тестирование

Тесты находятся в директории `tests`.
Там же в файлах `expected.txt` записаны правильные (наверное) ответы на них.
Для проверки вашего решения запускается несколько бинарей, каждый из которых
проверяет свой набор файлов:

* `test_check_names_no_dict` - файлы из `no-dict` (без словаря)
* `test_check_names_checker` - ваш код из `checker` (без словаря)
* `test_check_names_dict` - файлы из `dict` (со словарём)

Если одно и то же событие случилось несколько раз, например,
переменная с невалидным именем объявлена несколько раз --- такое
может быть в случае static-членов класса, выводите информацию о каждом событии.
Если ближайших слов к данному несколько, берите
первое по порядку в словаре.

В этой задаче отключена проверка на утечку памяти.

По данному заданию не будет ревью, однако мы выборочном просмотрим некоторые
посылки на предмет наличия ~~bullshit'а~~ интересных решений.
