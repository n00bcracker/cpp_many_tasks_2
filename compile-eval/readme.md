# Вычисления на этапе компиляции

В этой задаче вам предстоит немного погрузиться в удивительный
мир вычислений во время компиляции. Будьте аккуратны при компиляции
тех или иных решений в этой задаче (например, next prime).
При неаккуратной реализации время компиляции может быть сколь угодно долгим,
а потребляемая при этом память сколь угодно большой
(вплоть до исчерпания всей вашей RAM).

Данная задача включает в себя 6 подзадач:

## C++03

В этой секции используется старый стандарт языка C++03. Это означает,
что для организации вычислений вы можете использовать
только механизм инстанцирования шаблонов (см. ссылки).

### Template pow

Реализуйте шаблон `Pow<int, int>`, приведенный в файле `pow.h`. В `Pow<a, b>::kValue`
должен быть результат выражения $`a^b`$. Считайте, что $`a > 0, b \ge 0`$. 

### Template sqrt

Реализуйте шаблон `Sqrt<n>`, приведенный в файле `sqrt.h`. В `Sqrt<n>::kValue`
должно быть такое наименьшее x, что $`x * x \ge n`$.
Воспользуйтесь бинарным поиском для вычисления результата.
Вам также может понадобиться реализовать свой аналог `std::conditional`.

### Полезные ссылки
* https://en.wikipedia.org/wiki/Compile_time_function_execution
* https://www.ozon.ru/context/detail/id/3960662/ глава "Метапрограммы".
* https://en.cppreference.com/w/cpp/types/conditional

## C++11

В этой секции используется стандарт C++11. Это означает,
что вам теперь доступны `constexpr` выражения.
Однако в этой версии стандарта на constexpr-функции наложены довольно строгие ограничения
(например, функция может представлять собой только выражение вида return ...).

### Pow

Реализуйте функцию `Pow(int, int)`, приведенную в `another_pow.h`.
Теперь используйте возможности constexpr вместо шаблонов.

### Hash

Реализуйте функцию `Hash(const char* s, int p, int m)`, приведенную в `hash.h`.
Данная функция должна вычислять следующий
полиномиальный хеш строки s на этапе компиляции:
```math
h = \sum\limits_{i = 0}^{|s| - 1} s_i * p^{i} (mod \; m)
```

Подумайте, как переписать эту формулу в рекуррентном виде, а затем реализуйте полученное.

### Полезные ссылки
* https://en.cppreference.com/w/cpp/language/constexpr

## C++14

В этой секции используется стандарт C++14, который существенно ослабил ограничения,
налагаемые на constexpr функции,
а также ввёл широкую поддержку constexpr стандартной библиотекой.
Это позволяет реализовывать намного более сложные алгоритмы на этапе компиляции.
Например, теперь можно объявлять переменные внутри функций
(и даже создавать объекты, если у них есть constexpr
конструкторы), а также писать циклы и условные выражения.

### Next prime

Реализуйте функцию `NextPrime(int)`, приведенную в файле `next_prime.h`.
Данная функция по заданному `x` находит такое наименьшее $`y \ge x`$, что y --- простое.

### Determinant

Реализуйте функцию `Determinant` в файле `determinant.h`.
Данная функция должна вычислять определитель заданной квадратной матрицы.
В этой задаче вам могут понадобиться шаблоны с переменным
числом аргументов, появившиеся в C++11.

### Полезные ссылки
* https://en.cppreference.com/w/cpp/language/parameter_pack
* https://eli.thegreenplace.net/2014/variadic-templates-in-c/
* https://habrahabr.ru/post/228031/
* https://en.cppreference.com/w/cpp/utility/integer_sequence
