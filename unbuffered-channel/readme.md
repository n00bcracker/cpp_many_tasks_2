# Unbuffered channel

*Перед выполнением этой задачи стоит решить предыдущую: [buffered-channel](../buffered-channel/).*

После реализации буферизированного канала вы можете приступить к реализации небуферизированного. Его операции отличаются следующим:
* `Send(value)` — поток блокируется до тех пор, пока принимающая сторона не получит соответствующее `value`.
* `Recv()` — поток блокируется до тех пор, пока не появится какой-либо `Send`, который можно принять.
* `Close()` — закрыть канал. Если при этом есть какие-то ожидающие `send` потоки, то и они, и все последующие попытки `Send` должны завершаться с ошибкой.
А все вызовы `Recv` (как последующие, так и текущие ожидающие) должны возвращать значение, свидетельствующее о том, что канал закрыт.

Как видно из описания, если в буферизированном канале операции Send-Recv являются асинхронными, то в небуферизированном они синхронны.
Сделавший `Send` (при выходе из него) гарантированно знает, что другой поток уже получил соответствующее `value`. Разумеется, такая синхронизация стоит затрат и небуферизированный канал
обычно менее эффективен. Однако его можно использовать как примитив синхронизации различных потоков.

Реализуйте описанный канал в файле `unbuffered_channel.h`. Требования к операциям аналогичны предыдущей задаче:
* `Send` должен бросать исключение типа `std::runtime_error` при закрытии канала.
* `Recv` возвращает `std::optional`, в котором нет значения если канал был закрыт.

Для понимания алгоритма полезно следующее наблюдение: в предыдущей задаче канал имел явное состояние в виде буфера. Вся синхронизация работала с этим состоянием. Однако помимо буфера
в канале было и неявное состояние в виде очереди ожидающих доставки сообщения в буфер (т.е. появляения в нем свободного места). В этой задаче сообщения доставляются напрямую получателю, а значит
описанное неявное состояние тут придется сделать явным и работать уже с ним.

### Ограничения
Время выполнения каждого бенчмарка не должно превышать 7.5 секунд.
