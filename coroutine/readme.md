# Coroutine

[Корутина](https://en.cppreference.com/w/cpp/language/coroutines) - это функция,
которая может приостановить (suspend) исполнение, чтобы возобновить (resume) его позже.

В этом задании мы реализуем простейшую корутину, её исполнение может
встать на паузу в связи с желанием дождаться некоторого момента времени (TimePoint) или
желанием приостановиться на определённый временной интервал (Duration).

Управлением корутин занимается класс `Scheduler`. Он хранит множество ещё не выполненных
корутин. При вызове метода `Step` планировщик продолжает исполнение одной из них.
Выбор корутины производится на основании следующих правил:
* Если есть корутина, которая ещё не начинала исполнение, то выбирается она
* Иначе мы в ситуации, когда все корутины дожидаются некоторых моментов времени.
В этом случае алгоритм такой:
    1. Выбирается корутина с минимальным временем
    2. Вся программа приостанавливается до этого времени
    3. Выбранная корутина продолжает исполнение
* Если есть неоднозначность
(несколько корутин ещё не начали исполнение или несколько ждут на минимальном времени),
то выбирается самая ранее добавленная в планировщик через метод `Scheduler::AddTask`

Пример:

```cpp
Coroutine TaskA() {
    std::cout << 1;
    co_await 100ms;
    std::cout << 2;
    co_await 100ms;
    std::cout << 3;
}

Coroutine TaskB() {
    std::cout << 4;
    co_await 40ms;
    std::cout << 5;
    co_await 140ms;
    std::cout << 6;
}

int main() {
    Scheduler scheduler;
    scheduler.AddTask(TaskA);
    scheduler.AddTask(TaskB);
    scheduler.Step(); // 1
    scheduler.Step(); // 4
    scheduler.Step(); // 5 (после 40 мс ожидания)
    scheduler.Step(); // 2 (после 60 мс ожидания)
    scheduler.Step(); // 6 (после 80 мс ожидания)
}
```

Данная программа будет выполняться примерно 180 мс и напечатает `14526`.

Для использования корутин C++ требует написания некоторых классов и методов,
где описывается поведение корутин.
Заготовка написана за вас, код должен компилироваться. Текущая реализация планировщика
выполняет корутины по очереди, игнорируя времена ожидания.

### Полезные ссылки

- [Coroutines](https://en.cppreference.com/w/cpp/language/coroutines) -
основная статья про корутины на cppreference. Здесь можно посмотреть в какой момент
какие методы вызываются у классов Promise и Awaiter
- [std::coroutine_handle](https://en.cppreference.com/w/cpp/coroutine/coroutine_handle)

### Примечания

* Корутина должна вставать на паузу даже если time_point уже прошёл или если duration отрицательный
* Запрещено использование потоков
